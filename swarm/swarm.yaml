version: "1"

tasks:
  planner:
    prompt-string: |
      # Planner Agent Prompt

      Note that whatever task file you create - it must be small enough to fit into a single agents context window of about 100k tokens.

      1. Review Improvement Opportunities
         - Examine swarm/PLAN.md and the codebase for potential improvements, such as missing commands or incomplete features.

      2. If No Improvements Are Found
         - Propose an original, highly useful feature for agents working on the project.

      3. Write a Feature Plan
         - Plan the improvement or feature and save the plan to ./swarm/todo/{feature-name}.pending.md.

      4. Exit Criteria
         - Exit immediately after writing one feature plan or if no improvements can be identified.

  coder:
    prompt-string: |
      # Task Workflow for the Coder Agent

      1. **Resume Unfinished Work**
         - Check for your own unfinished tasks: look for files matching `./swarm/todo/*.{SWARM_TASK_ID}.processing.md`.
         - If you find such a task, skip ahead to "Implement the Task".

      2. **Claim a Pending Task**
         - Search `./swarm/todo/` for files ending in `.pending.md`.
         - Choose a task that has no unresolved dependencies and won't conflict with any ongoing work.
         - Claim it by renaming it to `. {SWARM_TASK_ID}.processing.md`.
         - If no suitable pending tasks are available, skip to "If Nothing To Do".

      3. **Implement the Task**
         - Read your assigned task file and complete its requirements.
         - Add or update tests as needed, and validate your changes.
         - Once finished, rename the file to `.completed.md` and note your work.
         - If you are unable to finish, rename it back to `.pending.md` and briefly describe the problem encountered.

      4. **If Nothing To Do**
         - If no pending or processing tasks exist, test the current feature and report any issues found.
         - For each issue found, create a new pending task in the appropriate `swarm/todo/{feature-name}/` folder.
         - Exit immediately after reporting issues.

    depends_on: [planner]

  tester:
    prompt-string: |
      # Tester Agent Prompt

      You are a tester for a Go CLI tool called `desktop-cli`. Your job is to run unit tests,
      build the binary, and exercise the CLI to verify it behaves sensibly.

      ## 1. Run Unit Tests

      Run the full test suite:
      ```
      go test -v ./...
      ```
      Record any failures — test name, error message, and relevant output.

      ## 2. Build the CLI

      Build the binary from the project root:
      ```
      go build -o desktop-cli .
      ```
      If the build fails, record the compiler errors and skip to step 4.

      ## 3. Exercise the CLI

      Run the built binary with a variety of commands and check the output is sensible:

      - `./desktop-cli --help` — should print usage info listing all subcommands
      - `./desktop-cli list --help` — should print help for the list subcommand
      - `./desktop-cli read --help` — should print help for the read subcommand
      - `./desktop-cli click --help` — should print help for the click subcommand
      - `./desktop-cli type --help` — should print help for the type subcommand
      - `./desktop-cli scroll --help` — should print help for the scroll subcommand
      - `./desktop-cli drag --help` — should print help for the drag subcommand
      - `./desktop-cli focus --help` — should print help for the focus subcommand
      - `./desktop-cli screenshot --help` — should print help for the screenshot subcommand
      - `./desktop-cli action --help` — should print help for the action subcommand
      - `./desktop-cli set-value --help` — should print help for the set-value subcommand
      - `./desktop-cli wait --help` — should print help for the wait subcommand
      - `./desktop-cli --version` — should print a version string
      - `./desktop-cli list --windows` — should produce YAML output (may be empty but should not error)
      - `./desktop-cli list --apps` — should produce YAML output (may be empty but should not error)
      - `./desktop-cli read --app "NonExistentApp12345"` — should exit gracefully with a clear error, not panic

      For each command:
      - Verify the exit code is 0 for help/list commands and non-zero for expected errors.
      - Verify stdout/stderr looks reasonable (no stack traces, no panics, no garbled output).
      - Verify help output mentions the expected flags for that subcommand.
      - If any issues, write them to a ./swarm/todo/{issue-name}.pending.md file with a clear description of the problem and steps to reproduce.

      ## 4. Write or Improve Unit Tests

      If you find gaps in test coverage — areas of the code that are exercised by the CLI but not
      covered by unit tests — write new tests or improve existing ones. Focus on:
      - Edge cases you discovered during CLI testing
      - Error handling paths
      - Flag validation and argument parsing

      Run `go test -v ./...` again after adding tests to make sure they pass.

      ## 5. Report Results

      - If all tests pass and the CLI behaves correctly, clean up the built binary (`rm -f desktop-cli`)
        and exit.
      - If you find bugs or issues, create a new pending task for each one in `./swarm/todo/{issue-name}.pending.md`
        with a clear description of the problem and steps to reproduce.
      - If you wrote new tests, make sure they are committed-ready (compile and pass).

    depends_on: [coder]

  checker:
    prompt-string: |
      # Review unstaged git changes for bugs

      Run `git diff` to see all unstaged changes in the repository.

      # Analyze the changes for bugs

      Carefully review the diff output and look for bugs such as:
      - Off-by-one errors or incorrect boundary conditions
      - Null/undefined access without proper guards
      - Race conditions or missing awaits on async calls
      - Incorrect logic (wrong operator, inverted condition, swapped arguments)
      - Unhandled error cases or missing try/catch blocks
      - Security issues (unsanitized input, exposed secrets, injection vectors)
      - State management bugs (stale closures, missing dependency arrays, mutation of shared state)
      - Type mismatches or unsafe casts that could cause runtime errors

      # Fix bugs

      If you find bugs, fix them directly in the code.
      Keep fixes minimal and targeted — only fix actual bugs, don't refactor or add features.
      Make sure the code still compiles and any relevant tests still pass after your fixes.

      # If no bugs found

      If the unstaged changes look correct, git commit and push and then exit immediately.

    depends_on: [tester]

pipelines:
  development:
    iterations: 30
    parallelism: 2
    tasks: [planner, coder, tester, checker]
