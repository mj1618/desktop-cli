version: "1"

tasks:
  planner:
    prompt-string: |
      # Planner Agent Prompt

      1. Review Improvement Opportunities
         - Examine swarm/PLAN.md and the codebase for potential improvements, such as missing commands or incomplete features.

      2. If No Improvements Are Found
         - Propose an original, highly useful feature for agents working on the project.

      3. Write a Feature Plan
         - Plan the improvement or feature and save the plan to ./swarm/todo/{feature-name}.pending.md.

      4. Exit Criteria
         - Exit immediately after writing one feature plan or if no improvements can be identified.

  coder:
    prompt-string: |
      # Task Workflow for the Coder Agent

      1. **Resume Unfinished Work**
         - Check for your own unfinished tasks: look for files matching `./swarm/todo/*.{SWARM_TASK_ID}.processing.md`.
         - If you find such a task, skip ahead to "Implement the Task".

      2. **Claim a Pending Task**
         - Search `./swarm/todo/` for files ending in `.pending.md`.
         - Choose a task that has no unresolved dependencies and won't conflict with any ongoing work.
         - Claim it by renaming it to `. {SWARM_TASK_ID}.processing.md`.
         - If no suitable pending tasks are available, skip to "If Nothing To Do".

      3. **Implement the Task**
         - Read your assigned task file and complete its requirements.
         - Add or update tests as needed, and validate your changes.
         - Once finished, rename the file to `.completed.md` and note your work.
         - If you are unable to finish, rename it back to `.pending.md` and briefly describe the problem encountered.

      4. **If Nothing To Do**
         - If no pending or processing tasks exist, test the current feature and report any issues found.
         - For each issue found, create a new pending task in the appropriate `swarm/todo/{feature-name}/` folder.
         - Exit immediately after reporting issues.

    depends_on: [planner]

  refactor:
    prompt-string: |
      # Review unstaged git changes for refactoring opportunities

      Run `git diff` to see all unstaged changes in the repository.

      # Analyze the changes

      Look through the diff output and identify refactoring opportunities such as:
      - Code duplication that could be extracted into shared functions/components
      - Overly complex functions that should be broken down
      - Poor naming that could be clarified
      - Missing type safety or loose typing
      - Dead code or unused imports introduced by the changes
      - Inconsistent patterns compared to the rest of the codebase

      # Apply refactors

      If you find refactoring opportunities, apply them directly to the code.
      Keep changes minimal and focused — don't refactor code outside of what was touched by the unstaged changes.
      Make sure the code still compiles and any relevant tests still pass after your refactors.

      # If nothing to refactor

      If the unstaged changes look clean, exit immediately.

    depends_on: [coder]

  checker:
    prompt-string: |
      # Review unstaged git changes for bugs

      Run `git diff` to see all unstaged changes in the repository.

      # Analyze the changes for bugs

      Carefully review the diff output and look for bugs such as:
      - Off-by-one errors or incorrect boundary conditions
      - Null/undefined access without proper guards
      - Race conditions or missing awaits on async calls
      - Incorrect logic (wrong operator, inverted condition, swapped arguments)
      - Unhandled error cases or missing try/catch blocks
      - Security issues (unsanitized input, exposed secrets, injection vectors)
      - State management bugs (stale closures, missing dependency arrays, mutation of shared state)
      - Type mismatches or unsafe casts that could cause runtime errors

      # Fix bugs

      If you find bugs, fix them directly in the code.
      Keep fixes minimal and targeted — only fix actual bugs, don't refactor or add features.
      Make sure the code still compiles and any relevant tests still pass after your fixes.

      # If no bugs found

      If the unstaged changes look correct, exit immediately.

    depends_on: [refactor]

  tester:
    prompt-string: |
      # Run final tests

      Run the full test suite to make sure everything passes:
      - Run `npm test` (or the appropriate test command for this project)
      - Run `npm run build` to verify the project compiles cleanly
      - If there are linting scripts configured, run those too

      # Fix any failures

      If any tests fail or the build breaks:
      - Read the error output carefully
      - Fix the issues directly in the code
      - Re-run the failing tests to confirm the fix
      - Repeat until everything passes

      # Push to git

      Once all tests pass and the build is clean:
      - Run `git add -A` to stage all changes
      - Run `git diff --cached --stat` to review what will be committed
      - Write a concise, descriptive commit message summarizing the changes made in this iteration
      - Run `git commit` with that message
      - Run `git push` to push the commit to the remote

      # If nothing to push

      If there are no unstaged or staged changes (nothing was modified in this iteration), exit immediately.

    depends_on: [checker]

pipelines:
  development:
    iterations: 30
    tasks: [planner, coder, refactor, checker, tester]
